<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spark on Kirill Pavlov</title>
    <link>http://kirillpavlov.com/categories/spark/</link>
    <description>Recent content in Spark on Kirill Pavlov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 23 Apr 2016 09:40:05 +0800</lastBuildDate>
    
	<atom:link href="http://kirillpavlov.com/categories/spark/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Beyond traditional join with Apache Spark</title>
      <link>http://kirillpavlov.com/blog/2016/04/23/beyond-traditional-join-with-apache-spark/</link>
      <pubDate>Sat, 23 Apr 2016 09:40:05 +0800</pubDate>
      
      <guid>http://kirillpavlov.com/blog/2016/04/23/beyond-traditional-join-with-apache-spark/</guid>
      <description>An [SQL join](https://en.wikipedia.org/wiki/Join_(SQL)) clause combines records from two or more tables. This operation is very common in data processing and understanding of what happens under the hood is important. There are several common join types: INNER, LEFT OUTER, RIGHT OUTER, FULL OUTER and CROSS or CARTESIAN.
 Join which uses the same table is a self-join. If an operation uses equality operator, it is [equi-join](https://en.wikipedia.org/wiki/Join_(SQL)#Equi-join), otherwise, it is non-equi-join.</description>
    </item>
    
    <item>
      <title>Top 5 features released in spark 1.6</title>
      <link>http://kirillpavlov.com/blog/2016/02/21/top-5-features-released-in-spark-1.6/</link>
      <pubDate>Sun, 21 Feb 2016 00:20:45 +0800</pubDate>
      
      <guid>http://kirillpavlov.com/blog/2016/02/21/top-5-features-released-in-spark-1.6/</guid>
      <description>Spark version 1.6 has been released on January 4th, 2016. Compared to the previous version, it has significant improvements. This article covers top 5 of them.
1. Partition by column The idea is to have more control on RDD&amp;rsquo;s partitioning. Sometimes data needs to be joined and grouped by certain key, such as user_id. To minify data reshuffling, one may possible to store chunks of objects with the same key within the same data node.</description>
    </item>
    
  </channel>
</rss>